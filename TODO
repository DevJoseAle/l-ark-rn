

---

### 1.2 Terms & Conditions + Privacy Policy (Legal) üìÑ **CR√çTICO**
**Descripci√≥n:** Textos legales finales y aceptaci√≥n obligatoria
```
Web:
‚ñ° Modificar /terms.astro y /es/terms.astro
  - Reemplazar placeholders con texto legal real
  - Definir: refund policy, data retention, liability limits
  - Consultar con abogado si es posible

‚ñ° Modificar /privacy.astro y /es/privacy.astro
  - Detalles de procesamiento de datos
  - Informaci√≥n de Stripe (PCI compliance)
  - Cookies policy
  - GDPR compliance (si aplica)

Mobile:
‚ñ° Modal de T√©rminos y Condiciones
  - Componente: AcceptTermsModal.tsx
  - Mostrar al crear cuenta (signup)
  - Mostrar al crear campa√±a (si no ha aceptado)
  - Checkboxes:
    [x] Acepto los T√©rminos y Condiciones
    [x] Acepto la Pol√≠tica de Privacidad
  - Botones: "Leer" (abre web) + "Aceptar y Continuar"
  - Bloquear acci√≥n hasta que acepte

‚ñ° Tabla en Supabase: user_terms_acceptance
  Schema:
  - id: uuid (PK)
  - user_id: uuid (FK ‚Üí users)
  - accepted_at: timestamptz
  - terms_version: text (ej: "v1.0")
  - privacy_version: text (ej: "v1.0")
  - ip_address: text (opcional)
  - created_at: timestamptz
  
  RLS policies:
  - SELECT: solo el propio usuario
  - INSERT: solo autenticados

‚ñ° Service: termsAcceptance.service.ts
  - checkIfUserAccepted(userId): boolean
  - recordAcceptance(userId, termsVersion, privacyVersion)
  - getAcceptanceHistory(userId)

‚ñ° Integraci√≥n en flows:
  - Signup: mostrar modal antes de crear cuenta
  - Login: verificar si acept√≥, sino mostrar modal
  - Create Campaign: verificar aceptaci√≥n
```

**Estimaci√≥n:** 2 d√≠as  
**Dependencias:** Texto legal final

---

### 1.3 Deploy en Stores y Hosting üöÄ **BLOQUEANTE**
**Descripci√≥n:** Publicar app y web en producci√≥n
```
Mobile - Apple App Store:
‚ñ° Configurar App Store Connect
  - Crear app listing
  - Screenshots (6.5", 6.7", 12.9" iPad)
  - Description, keywords, category
  - Age rating
  - Privacy policy URL (link a web)

‚ñ° Build de producci√≥n
  - eas build --platform ios --profile production
  - Incrementar version y build number
  - Certificados de distribuci√≥n

‚ñ° Subir a TestFlight
  - eas submit --platform ios
  - Testing interno (1-2 d√≠as)
  - Corregir bugs cr√≠ticos

‚ñ° Submit for Review
  - Completar App Review Information
  - Notes para reviewers (c√≥mo testear)
  - Esperar aprobaci√≥n (2-7 d√≠as)

Mobile - Google Play Store:
‚ñ° Configurar Google Play Console
  - Crear app listing
  - Screenshots (phone, tablet)
  - Description, keywords, category
  - Content rating questionnaire
  - Privacy policy URL

‚ñ° Build de producci√≥n
  - eas build --platform android --profile production
  - App Bundle (.aab)
  - Incrementar versionCode y versionName

‚ñ° Internal testing track
  - Subir .aab
  - Testing interno (1-2 d√≠as)
  - Corregir bugs cr√≠ticos

‚ñ° Production release
  - Mover a production track
  - Rollout percentage (ej: 10% ‚Üí 50% ‚Üí 100%)
  - Monitorear crashes

Web - Hostinger:
‚ñ° Configurar dominio
  - Comprar dominio (ej: lark.app)
  - Configurar DNS en Hostinger
  - SSL/TLS certificate

‚ñ° Build de producci√≥n
  - npm run build
  - Verificar que no hay errores
  - Testing local: npm run preview

‚ñ° Deploy
  - M√©todo 1: FTP/SFTP manual
  - M√©todo 2: Git deployment
  - M√©todo 3: Hostinger Website Builder (si aplica)
  - Subir carpeta dist/

‚ñ° Configuraci√≥n post-deploy
  - Verificar rutas funcionan (SSR)
  - Configurar redirects (.htaccess si es Apache)
  - Verificar /es/* routes
  - Testing en navegadores (Chrome, Safari, Firefox)
  - Lighthouse audit

‚ñ° Dominio custom en Supabase
  - Configurar custom domain para storage URLs
  - O usar CDN (Cloudflare)
```

**Estimaci√≥n:** 3-4 d√≠as (m√°s tiempos de review)  
**Dependencias:** T&C completados, testing QA

---

## üü° **PRIORIDAD 2: IMPORTANTES PARA UX**

### 2.1 Notificaciones Email üì¨
**Descripci√≥n:** Mantener a usuarios informados de eventos importantes
```
Backend:
‚ñ° Edge Function: send-notification (completar)
  - Integraci√≥n Resend (email)
  - Templates HTML para:
    1. Bienvenida (signup)
    2. KYC enviado (review)
    3. KYC aprobado
    4. KYC rechazado (con raz√≥n)
    5. Agregado como beneficiario
    6. Donaci√≥n recibida (owner)
    7. Causal activada (beneficiarios)
    8. Pago recibido (beneficiario)
  - Testing de env√≠o

‚ñ° Integrar con webhooks existentes
  - stripe-payment-webhook: enviar email al owner
  - stripe-connect-webhook: notificar cambios de estado
  - distribute-campaign-funds: notificar payouts
```

**Estimaci√≥n:** 1.5 d√≠as  
**Dependencias:** Ninguna

---

### 2.2 Stripe Connect Onboarding UI Completo üí≥
**Descripci√≥n:** Facilitar que beneficiarios completen verificaci√≥n
```
Mobile:
‚ñ° Pantalla: Verification Status
  - Ruta: app/(auth)/profile/verification.tsx
  - Mostrar estado actual (invited, pending, onboarding, verified, active)
  - Card visual con iconos y colores seg√∫n estado

‚ñ° Bot√≥n para iniciar/continuar onboarding
  - Solo mostrar si:
    1. Usuario es beneficiario
    2. Pa√≠s soporta Connect (US, MX, CO)
    3. Estado != 'active'
  - Al tap:
    1. Llamar a stripe-connect-onboarding-link
    2. Obtener URL
    3. Abrir en WebBrowser.openAuthSessionAsync()
    4. Esperar retorno (refresh_url)

‚ñ° Manejo de retorno
  - Usuario completa en Stripe
  - Stripe redirige a refresh_url
  - App detecta retorno (deep link)
  - Refrescar connect_status

‚ñ° UI States
  - Invited/Pending: "Completar Verificaci√≥n" (bot√≥n primary)
  - Onboarding: "Continuar Verificaci√≥n" (bot√≥n secondary)
  - Verified: "Verificado ‚úì" (badge verde)
  - Active: Mostrar info de cuenta bancaria

Backend:
‚ñ° Edge Function: stripe-connect-refresh-url
  - Generar refresh_url para continuar onboarding
  - Si ya complet√≥, return account status
```

**Estimaci√≥n:** 1 d√≠a  
**Dependencias:** Deep linking configurado

---

### 2.3 Deep Linking Completo üîó
**Descripci√≥n:** Terminar configuraci√≥n de deep links para compartir campa√±as
```
Mobile:
‚ñ° Configurar Universal Links (iOS)
  - Crear apple-app-site-association
  - Subir a https://lark.app/.well-known/
  - Agregar Associated Domains en Xcode

‚ñ° Configurar App Links (Android)
  - Crear assetlinks.json
  - Subir a https://lark.app/.well-known/
  - Verificar en Play Console

‚ñ° Testing de deep links
  - Desde navegador (Chrome, Safari)
  - Desde apps (WhatsApp, Telegram, Instagram)
  - Fallback a web si app no instalada

Web:
‚ñ° Meta tags para compartir
  - og:title, og:description, og:image
  - twitter:card
  - Dynamic por campa√±a

‚ñ° Dynamic Links (opcional)
  - Firebase Dynamic Links
  - O branch.io
  - Para mejores analytics
```

**Estimaci√≥n:** 1-2 d√≠as  
**Dependencias:** Web deployada en dominio real

---

### 2.4 Notificaciones Push (Mobile) üì±
**Descripci√≥n:** Push notifications para eventos cr√≠ticos
```
Mobile:
‚ñ° Configurar Expo Notifications
  - expo-notifications ya instalado ‚úì
  - Pedir permisos (iOS/Android)
  - Obtener push token

‚ñ° Guardar tokens en DB
  - Tabla: user_devices (crear si no existe)
  - Campos: user_id, push_token, platform, is_active
  - Actualizar token al login

‚ñ° Enviar notificaciones desde Edge Functions
  - Usar Expo Push API
  - Notificar eventos cr√≠ticos:
    - Donaci√≥n recibida
    - Causal activada
    - Pago recibido
  - Badge count en iOS

‚ñ° Manejar notificaciones en app
  - useNotifications hook
  - Navegar a pantalla correcta al tap
  - Mostrar in-app cuando app est√° abierta
```

**Estimaci√≥n:** 2 d√≠as  
**Dependencias:** Ninguna

---

### 2.5 Compartir Certificado de Campa√±a üéñÔ∏è
**Descripci√≥n:** Generar imagen para compartir cuando se crea campa√±a
```
Backend:
‚ñ° Edge Function: generate-campaign-certificate
  - Input: campaignId
  - Generar imagen con:
    - Logo de L-ark
    - T√≠tulo de campa√±a
    - Nombre del owner
    - Fecha de creaci√≥n
    - QR code o short link a campa√±a
    - "Certified Digital Legacy Campaign"
  - Usar librer√≠a: @vercel/og o similar
  - Guardar en Supabase Storage
  - Return URL

Mobile:
‚ñ° Pantalla post-creaci√≥n
  - Despu√©s de crear campa√±a exitosamente
  - Mostrar certificado (Image)
  - Botones:
    [Compartir en RRSS]
    [Descargar]
    [Continuar]

‚ñ° Compartir en RRSS
  - Expo Sharing
  - Opciones: Instagram, Facebook, Twitter, WhatsApp
  - Texto pre-llenado:
    "¬°Acabo de crear mi legado digital en L-ark! 
    Apoya mi campa√±a: [link]"

Web:
‚ñ° Mostrar certificado en /campaign/[id]
  - Secci√≥n "Share Your Certificate"
  - Download button
  - Social share buttons
```

**Estimaci√≥n:** 2 d√≠as  
**Dependencias:** Edge Function para generar imagen

---

## üü¢ **PRIORIDAD 3: MEJORAS Y OPTIMIZACIONES**

### 3.1 Sistema de Favoritos ‚≠ê
```
Mobile:
‚ñ° Tabla: campaign_favorites
  - user_id, campaign_id, created_at
  - Unique constraint (user_id, campaign_id)
  
‚ñ° Bot√≥n favorito en CampaignCard
  - Icono: coraz√≥n outline/filled
  - Toggle favorito
  
‚ñ° Tab de Favoritos
  - En home o perfil
  - Lista de campa√±as favoritas
  - Empty state
```

**Estimaci√≥n:** 1 d√≠a

---

### 3.2 B√∫squeda y Filtros de Campa√±as üîç
```
Mobile:
‚ñ° Pantalla de b√∫squeda
  - Search bar
  - Filtros:
    - Pa√≠s
    - Rango de meta ($1k-$10k, $10k-$50k, etc.)
    - Status (active, completed)
  - Resultados paginados (infinite scroll)
  
‚ñ° Supabase query con filtros
  - .ilike() para texto
  - .gte() / .lte() para montos
  - .eq() para pa√≠s
```

**Estimaci√≥n:** 1-2 d√≠as

---

### 3.3 Suscripciones IAP (Vault PRO) üíé
```
Mobile:
‚ñ° Integraci√≥n React Native Purchases
  - Configurar productos en App Store Connect
  - Configurar productos en Google Play Console
  - Inicializar SDK
  
‚ñ° Flujo de compra
  - Mostrar planes (ya existe UI)
  - Purchases.purchasePackage()
  - Manejar estados (purchasing, purchased, error)
  
‚ñ° Verificaci√≥n de recibos
  - Edge Function: verify-iap-receipt
  - Apple: verifyReceipt API
  - Google: Play Developer API
  - Actualizar vault_subscriptions
  
‚ñ° Renovaci√≥n autom√°tica
  - Webhook de Apple/Google
  - Actualizar current_period_end
  - Notificar usuario
```

**Estimaci√≥n:** 3-4 d√≠as

---

### 3.4 Analytics y Monitoreo üìä
```
Web:
‚ñ° Google Analytics 4
  - Crear property
  - Instalar gtag.js
  - Eventos custom:
    - campaign_view
    - donation_started
    - donation_completed
  
Mobile:
‚ñ° Expo Analytics
  - O Firebase Analytics
  - Eventos:
    - campaign_created
    - vault_file_uploaded
    - profile_updated
```

**Estimaci√≥n:** 1 d√≠a

---

### 3.5 Optimizaciones Web üöÄ
```
‚ñ° Lazy loading de im√°genes
  - Usar loading="lazy"
  - Placeholder blur
  
‚ñ° Image CDN
  - Cloudflare Images
  - O imgix
  - Resize autom√°tico
  
‚ñ° Code splitting
  - Dynamic imports
  - Route-based splitting
  
‚ñ° Lighthouse audit
  - Performance: 90+
  - Accessibility: 95+
  - Best Practices: 100
  - SEO: 100
```

**Estimaci√≥n:** 2 d√≠as

---

### 3.6 Newsletter Signup üìß
```
Web:
‚ñ° Form en footer
  - Input email + bot√≥n
  - Validaci√≥n
  
‚ñ° Integraci√≥n Resend
  - Agregar a lista
  - Email de confirmaci√≥n
```

**Estimaci√≥n:** 0.5 d√≠as

---

### 3.7 SEO Avanzado üîç
```
Web:
‚ñ° sitemap.xml din√°mico
  - Incluir todas las campa√±as activas
  - Regenerar diariamente
  
‚ñ° robots.txt
  - Allow: /
  - Disallow: /admin (si existe)
  - Sitemap: https://lark.app/sitemap.xml
```

**Estimaci√≥n:** 1 d√≠a

---

## üß™ **TESTING BACKEND (Para despu√©s del lanzamiento inicial)**

### Testing Completo del Sistema de Distribuci√≥n
```
‚ñ° Testing de distribute-campaign-funds
  - Con cuentas Connect de testing
  - Verificar montos correctos (60%/40% splits)
  - Verificar platform_fee (8%)
  - Verificar actualizaci√≥n de campaign_balance
  - Logs en distribution_logs

‚ñ° Testing de errores
  - Cuenta no verificada
  - L√≠mites de Stripe
  - Saldo insuficiente
  - Beneficiario sin cuenta Connect

‚ñ° Testing de stripe-payment-webhook
  - Con Stripe CLI
  - Verificar idempotencia
  - Verificar actualizaci√≥n de balances
  - Verificar logs

‚ñ° Testing de stripe-connect-webhook
  - Simular account.updated
  - Simular cambios de estado
  - Verificar actualizaci√≥n de connect_status

‚ñ° Testing end-to-end en staging
  - Crear campa√±a ‚Üí Donar ‚Üí Activar causal ‚Üí Distribuir
  - Verificar toda la cadena funciona
  - Revisar logs completos

‚ñ° Edge Function: trigger-causal (crear si necesario)
  - Endpoint manual (admin) para activar causal
  - Validar que campa√±a est√© en 'active'
  - Cambiar status a 'triggered'
  - Notificar beneficiarios
  - Llamar a distribute-campaign-funds

  ‚ñ° Configurar stripe-payment-webhook en Stripe Dashboard
  - URL: https://[staging].supabase.co/functions/v1/stripe-payment-webhook
  - Events: checkout.session.completed, payment_intent.succeeded, payment_intent.payment_failed
  - Copiar webhook secret ‚Üí STRIPE_WEBHOOK_SECRET

‚ñ° Configurar stripe-connect-webhook en Stripe Dashboard
  - URL: https://[staging].supabase.co/functions/v1/stripe-connect-webhook
  - Events: account.updated, account.external_account.created
  - Copiar webhook secret ‚Üí STRIPE_CONNECT_WEBHOOK_SECRET

‚ñ° Agregar secrets a Supabase
  - STRIPE_SECRET_KEY
  - STRIPE_WEBHOOK_SECRET
  - STRIPE_CONNECT_WEBHOOK_SECRET

‚ñ° Testing con Stripe CLI
  - stripe listen --forward-to localhost:54321/functions/v1/stripe-payment-webhook
  - stripe trigger checkout.session.completed
  - Verificar logs en Supabase
```

**Estimaci√≥n:** 2-3 horas  
**Dependencias:** Ninguna



import { serve } from 'https://deno.land/std@0.192.0/http/server.ts';
import Stripe from 'https://esm.sh/stripe@14.11.0?target=deno';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';
const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') || '', {
  apiVersion: '2023-10-16',
  httpClient: Stripe.createFetchHttpClient()
});
const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET') || '';
serve(async (req)=>{
  const signature = req.headers.get('stripe-signature');
  if (!signature) {
    console.error('‚ùå No signature header');
    return new Response('No signature', {
      status: 400
    });
  }
  try {
    const body = await req.text();
    console.log('üì• Webhook received');
    const event = await stripe.webhooks.constructEventAsync(body, signature, webhookSecret, undefined, Stripe.createSubtleCryptoProvider());
    console.log('‚úÖ Event verified:', event.type);
    const supabase = createClient(Deno.env.get('SUPABASE_URL') ?? '', Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '');
    switch(event.type){
      case 'checkout.session.completed':
        {
          const session = event.data.object;
          console.log('üí≥ Checkout completed');
          console.log('üìÑ Session ID:', session.id);
          console.log('üí∞ Amount:', session.amount_total);
          const campaignId = session.metadata?.campaign_id;
          const amountTotal = session.amount_total || 0;
          const currency = session.currency?.toUpperCase() || 'USD';
          if (!campaignId) {
            console.error('‚ùå No campaign_id in metadata');
            break;
          }
          const amountInUnits = amountTotal / 100;
          console.log('üíæ Saving donation...');
          // ‚úÖ INSERTAR SEG√öN TU SCHEMA
          const { data: donation, error: donationError } = await supabase.from('donations').insert({
            campaign_id: campaignId,
            donor_user_id: null,
            amount: amountInUnits,
            currency: currency,
            amount_in_campaign_ccy: amountInUnits,
            status: 'paid',
            provider: 'stripe',
            provider_payment_id: session.payment_intent,
            provider_charge_id: session.id,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }).select().single();
          if (donationError) {
            console.error('‚ùå Error inserting donation:', donationError);
            console.error('‚ùå Error details:', JSON.stringify(donationError, null, 2));
            throw donationError;
          }
          console.log('‚úÖ Donation saved:', donation.id);
          // ‚úÖ ACTUALIZAR TOTAL DE LA CAMPA√ëA
          const { data: campaign, error: campaignError } = await supabase.from('campaigns').select('total_raised').eq('id', campaignId).single();
          if (campaignError) {
            console.error('‚ùå Error fetching campaign:', campaignError);
            throw campaignError;
          }
          const newTotal = (campaign.total_raised || 0) + amountInUnits;
          console.log('üìä Updating campaign total:', newTotal);
          const { error: updateError } = await supabase.from('campaigns').update({
            total_raised: newTotal,
            updated_at: new Date().toISOString()
          }).eq('id', campaignId);
          if (updateError) {
            console.error('‚ùå Error updating campaign:', updateError);
            throw updateError;
          }
          console.log('‚úÖ‚úÖ‚úÖ WEBHOOK COMPLETED SUCCESSFULLY ‚úÖ‚úÖ‚úÖ');
          break;
        }
      case 'payment_intent.succeeded':
        {
          console.log('‚úÖ Payment intent succeeded');
          break;
        }
      case 'payment_intent.payment_failed':
        {
          console.log('‚ùå Payment intent failed');
          break;
        }
      default:
        console.log(`‚ö†Ô∏è Unhandled event: ${event.type}`);
    }
    return new Response(JSON.stringify({
      received: true
    }), {
      status: 200,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('üí• WEBHOOK ERROR:', error.message);
    return new Response(JSON.stringify({
      error: error.message
    }), {
      status: 400,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }
});
